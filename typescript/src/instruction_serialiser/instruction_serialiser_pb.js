/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.instruction_serialiser.AddNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.AndNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.ArithmeticIfElseNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.ArithmeticResultNodeWrapper', null, global);
goog.exportSymbol('proto.instruction_serialiser.ArithmeticVariableNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.BoolNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.DivideNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.EqualNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.GreaterThanNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.GreaterThanOrEqualNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.InstructionWrapper', null, global);
goog.exportSymbol('proto.instruction_serialiser.LogarithmNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.LogicalIfElseNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.LogicalResultNodeWrapper', null, global);
goog.exportSymbol('proto.instruction_serialiser.LogicalVariableNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.ModuloNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.MultiplyNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.NegateNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.NumberNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.OrNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.PowerNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.SmallerThanNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.SmallerThanOrEqualNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.SubtractNode', null, global);
goog.exportSymbol('proto.instruction_serialiser.XorNode', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.InstructionWrapper = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.instruction_serialiser.InstructionWrapper.oneofGroups_);
};
goog.inherits(proto.instruction_serialiser.InstructionWrapper, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.InstructionWrapper.displayName = 'proto.instruction_serialiser.InstructionWrapper';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.instruction_serialiser.InstructionWrapper.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.instruction_serialiser.InstructionWrapper.WrapperCase = {
  WRAPPER_NOT_SET: 0,
  ARITHMETIC_WRAPPER: 1,
  LOGICAL_WRAPPER: 2
};

/**
 * @return {proto.instruction_serialiser.InstructionWrapper.WrapperCase}
 */
proto.instruction_serialiser.InstructionWrapper.prototype.getWrapperCase = function() {
  return /** @type {proto.instruction_serialiser.InstructionWrapper.WrapperCase} */(jspb.Message.computeOneofCase(this, proto.instruction_serialiser.InstructionWrapper.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.InstructionWrapper.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.InstructionWrapper.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.InstructionWrapper} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.InstructionWrapper.toObject = function(includeInstance, msg) {
  var f, obj = {
    arithmeticWrapper: (f = msg.getArithmeticWrapper()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    logicalWrapper: (f = msg.getLogicalWrapper()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.InstructionWrapper}
 */
proto.instruction_serialiser.InstructionWrapper.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.InstructionWrapper;
  return proto.instruction_serialiser.InstructionWrapper.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.InstructionWrapper} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.InstructionWrapper}
 */
proto.instruction_serialiser.InstructionWrapper.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setArithmeticWrapper(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLogicalWrapper(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.InstructionWrapper.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.InstructionWrapper.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.InstructionWrapper} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.InstructionWrapper.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getArithmeticWrapper();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getLogicalWrapper();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper arithmetic_wrapper = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.InstructionWrapper.prototype.getArithmeticWrapper = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.InstructionWrapper.prototype.setArithmeticWrapper = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.instruction_serialiser.InstructionWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.InstructionWrapper.prototype.clearArithmeticWrapper = function() {
  this.setArithmeticWrapper(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.InstructionWrapper.prototype.hasArithmeticWrapper = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional LogicalResultNodeWrapper logical_wrapper = 2;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.InstructionWrapper.prototype.getLogicalWrapper = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.InstructionWrapper.prototype.setLogicalWrapper = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.instruction_serialiser.InstructionWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.InstructionWrapper.prototype.clearLogicalWrapper = function() {
  this.setLogicalWrapper(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.InstructionWrapper.prototype.hasLogicalWrapper = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_);
};
goog.inherits(proto.instruction_serialiser.ArithmeticResultNodeWrapper, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.ArithmeticResultNodeWrapper.displayName = 'proto.instruction_serialiser.ArithmeticResultNodeWrapper';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_ = [[1,2,3,4,5,6,7,8,9,10]];

/**
 * @enum {number}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.NodeCase = {
  NODE_NOT_SET: 0,
  ADD_NODE: 1,
  DIVIDE_NODE: 2,
  MULTIPLY_NODE: 3,
  NUMBER_NODE: 4,
  SUBTRACT_NODE: 5,
  VARIABLE_NODE: 6,
  LOGARITHM_NODE: 7,
  POWER_NODE: 8,
  MODULO_NODE: 9,
  IF_ELSE_NODE: 10
};

/**
 * @return {proto.instruction_serialiser.ArithmeticResultNodeWrapper.NodeCase}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getNodeCase = function() {
  return /** @type {proto.instruction_serialiser.ArithmeticResultNodeWrapper.NodeCase} */(jspb.Message.computeOneofCase(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.ArithmeticResultNodeWrapper} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject = function(includeInstance, msg) {
  var f, obj = {
    addNode: (f = msg.getAddNode()) && proto.instruction_serialiser.AddNode.toObject(includeInstance, f),
    divideNode: (f = msg.getDivideNode()) && proto.instruction_serialiser.DivideNode.toObject(includeInstance, f),
    multiplyNode: (f = msg.getMultiplyNode()) && proto.instruction_serialiser.MultiplyNode.toObject(includeInstance, f),
    numberNode: (f = msg.getNumberNode()) && proto.instruction_serialiser.NumberNode.toObject(includeInstance, f),
    subtractNode: (f = msg.getSubtractNode()) && proto.instruction_serialiser.SubtractNode.toObject(includeInstance, f),
    variableNode: (f = msg.getVariableNode()) && proto.instruction_serialiser.ArithmeticVariableNode.toObject(includeInstance, f),
    logarithmNode: (f = msg.getLogarithmNode()) && proto.instruction_serialiser.LogarithmNode.toObject(includeInstance, f),
    powerNode: (f = msg.getPowerNode()) && proto.instruction_serialiser.PowerNode.toObject(includeInstance, f),
    moduloNode: (f = msg.getModuloNode()) && proto.instruction_serialiser.ModuloNode.toObject(includeInstance, f),
    ifElseNode: (f = msg.getIfElseNode()) && proto.instruction_serialiser.ArithmeticIfElseNode.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
  return proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.ArithmeticResultNodeWrapper} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.AddNode;
      reader.readMessage(value,proto.instruction_serialiser.AddNode.deserializeBinaryFromReader);
      msg.setAddNode(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.DivideNode;
      reader.readMessage(value,proto.instruction_serialiser.DivideNode.deserializeBinaryFromReader);
      msg.setDivideNode(value);
      break;
    case 3:
      var value = new proto.instruction_serialiser.MultiplyNode;
      reader.readMessage(value,proto.instruction_serialiser.MultiplyNode.deserializeBinaryFromReader);
      msg.setMultiplyNode(value);
      break;
    case 4:
      var value = new proto.instruction_serialiser.NumberNode;
      reader.readMessage(value,proto.instruction_serialiser.NumberNode.deserializeBinaryFromReader);
      msg.setNumberNode(value);
      break;
    case 5:
      var value = new proto.instruction_serialiser.SubtractNode;
      reader.readMessage(value,proto.instruction_serialiser.SubtractNode.deserializeBinaryFromReader);
      msg.setSubtractNode(value);
      break;
    case 6:
      var value = new proto.instruction_serialiser.ArithmeticVariableNode;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticVariableNode.deserializeBinaryFromReader);
      msg.setVariableNode(value);
      break;
    case 7:
      var value = new proto.instruction_serialiser.LogarithmNode;
      reader.readMessage(value,proto.instruction_serialiser.LogarithmNode.deserializeBinaryFromReader);
      msg.setLogarithmNode(value);
      break;
    case 8:
      var value = new proto.instruction_serialiser.PowerNode;
      reader.readMessage(value,proto.instruction_serialiser.PowerNode.deserializeBinaryFromReader);
      msg.setPowerNode(value);
      break;
    case 9:
      var value = new proto.instruction_serialiser.ModuloNode;
      reader.readMessage(value,proto.instruction_serialiser.ModuloNode.deserializeBinaryFromReader);
      msg.setModuloNode(value);
      break;
    case 10:
      var value = new proto.instruction_serialiser.ArithmeticIfElseNode;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticIfElseNode.deserializeBinaryFromReader);
      msg.setIfElseNode(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.ArithmeticResultNodeWrapper} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddNode();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.AddNode.serializeBinaryToWriter
    );
  }
  f = message.getDivideNode();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.DivideNode.serializeBinaryToWriter
    );
  }
  f = message.getMultiplyNode();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.instruction_serialiser.MultiplyNode.serializeBinaryToWriter
    );
  }
  f = message.getNumberNode();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.instruction_serialiser.NumberNode.serializeBinaryToWriter
    );
  }
  f = message.getSubtractNode();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.instruction_serialiser.SubtractNode.serializeBinaryToWriter
    );
  }
  f = message.getVariableNode();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.instruction_serialiser.ArithmeticVariableNode.serializeBinaryToWriter
    );
  }
  f = message.getLogarithmNode();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.instruction_serialiser.LogarithmNode.serializeBinaryToWriter
    );
  }
  f = message.getPowerNode();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.instruction_serialiser.PowerNode.serializeBinaryToWriter
    );
  }
  f = message.getModuloNode();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.instruction_serialiser.ModuloNode.serializeBinaryToWriter
    );
  }
  f = message.getIfElseNode();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      proto.instruction_serialiser.ArithmeticIfElseNode.serializeBinaryToWriter
    );
  }
};


/**
 * optional AddNode add_node = 1;
 * @return {?proto.instruction_serialiser.AddNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getAddNode = function() {
  return /** @type{?proto.instruction_serialiser.AddNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.AddNode, 1));
};


/** @param {?proto.instruction_serialiser.AddNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setAddNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearAddNode = function() {
  this.setAddNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasAddNode = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional DivideNode divide_node = 2;
 * @return {?proto.instruction_serialiser.DivideNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getDivideNode = function() {
  return /** @type{?proto.instruction_serialiser.DivideNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.DivideNode, 2));
};


/** @param {?proto.instruction_serialiser.DivideNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setDivideNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearDivideNode = function() {
  this.setDivideNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasDivideNode = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional MultiplyNode multiply_node = 3;
 * @return {?proto.instruction_serialiser.MultiplyNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getMultiplyNode = function() {
  return /** @type{?proto.instruction_serialiser.MultiplyNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.MultiplyNode, 3));
};


/** @param {?proto.instruction_serialiser.MultiplyNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setMultiplyNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearMultiplyNode = function() {
  this.setMultiplyNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasMultiplyNode = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional NumberNode number_node = 4;
 * @return {?proto.instruction_serialiser.NumberNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getNumberNode = function() {
  return /** @type{?proto.instruction_serialiser.NumberNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.NumberNode, 4));
};


/** @param {?proto.instruction_serialiser.NumberNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setNumberNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearNumberNode = function() {
  this.setNumberNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasNumberNode = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional SubtractNode subtract_node = 5;
 * @return {?proto.instruction_serialiser.SubtractNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getSubtractNode = function() {
  return /** @type{?proto.instruction_serialiser.SubtractNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.SubtractNode, 5));
};


/** @param {?proto.instruction_serialiser.SubtractNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setSubtractNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearSubtractNode = function() {
  this.setSubtractNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasSubtractNode = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional ArithmeticVariableNode variable_node = 6;
 * @return {?proto.instruction_serialiser.ArithmeticVariableNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getVariableNode = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticVariableNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticVariableNode, 6));
};


/** @param {?proto.instruction_serialiser.ArithmeticVariableNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setVariableNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 6, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearVariableNode = function() {
  this.setVariableNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasVariableNode = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional LogarithmNode logarithm_node = 7;
 * @return {?proto.instruction_serialiser.LogarithmNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getLogarithmNode = function() {
  return /** @type{?proto.instruction_serialiser.LogarithmNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogarithmNode, 7));
};


/** @param {?proto.instruction_serialiser.LogarithmNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setLogarithmNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 7, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearLogarithmNode = function() {
  this.setLogarithmNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasLogarithmNode = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional PowerNode power_node = 8;
 * @return {?proto.instruction_serialiser.PowerNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getPowerNode = function() {
  return /** @type{?proto.instruction_serialiser.PowerNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.PowerNode, 8));
};


/** @param {?proto.instruction_serialiser.PowerNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setPowerNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 8, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearPowerNode = function() {
  this.setPowerNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasPowerNode = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional ModuloNode modulo_node = 9;
 * @return {?proto.instruction_serialiser.ModuloNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getModuloNode = function() {
  return /** @type{?proto.instruction_serialiser.ModuloNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ModuloNode, 9));
};


/** @param {?proto.instruction_serialiser.ModuloNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setModuloNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 9, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearModuloNode = function() {
  this.setModuloNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasModuloNode = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional ArithmeticIfElseNode if_else_node = 10;
 * @return {?proto.instruction_serialiser.ArithmeticIfElseNode}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.getIfElseNode = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticIfElseNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticIfElseNode, 10));
};


/** @param {?proto.instruction_serialiser.ArithmeticIfElseNode|undefined} value */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.setIfElseNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 10, proto.instruction_serialiser.ArithmeticResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.clearIfElseNode = function() {
  this.setIfElseNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticResultNodeWrapper.prototype.hasIfElseNode = function() {
  return jspb.Message.getField(this, 10) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.LogicalResultNodeWrapper = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_);
};
goog.inherits(proto.instruction_serialiser.LogicalResultNodeWrapper, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.LogicalResultNodeWrapper.displayName = 'proto.instruction_serialiser.LogicalResultNodeWrapper';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_ = [[1,2,3,4,5,6,7,8,9,10,11,12]];

/**
 * @enum {number}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.NodeCase = {
  NODE_NOT_SET: 0,
  EQUAL_NODE: 1,
  AND_NODE: 2,
  BOOL_NODE: 3,
  NEGATE_NODE: 4,
  OR_NODE: 5,
  XOR_NODE: 6,
  VARIABLE_NODE: 7,
  IF_ELSE_NODE: 8,
  GREATER_THAN_NODE: 9,
  GREATER_THAN_OR_EQUAL_NODE: 10,
  SMALLER_THAN_NODE: 11,
  SMALLER_THAN_OR_EQUAL_NODE: 12
};

/**
 * @return {proto.instruction_serialiser.LogicalResultNodeWrapper.NodeCase}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getNodeCase = function() {
  return /** @type {proto.instruction_serialiser.LogicalResultNodeWrapper.NodeCase} */(jspb.Message.computeOneofCase(this, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.LogicalResultNodeWrapper} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.toObject = function(includeInstance, msg) {
  var f, obj = {
    equalNode: (f = msg.getEqualNode()) && proto.instruction_serialiser.EqualNode.toObject(includeInstance, f),
    andNode: (f = msg.getAndNode()) && proto.instruction_serialiser.AndNode.toObject(includeInstance, f),
    boolNode: (f = msg.getBoolNode()) && proto.instruction_serialiser.BoolNode.toObject(includeInstance, f),
    negateNode: (f = msg.getNegateNode()) && proto.instruction_serialiser.NegateNode.toObject(includeInstance, f),
    orNode: (f = msg.getOrNode()) && proto.instruction_serialiser.OrNode.toObject(includeInstance, f),
    xorNode: (f = msg.getXorNode()) && proto.instruction_serialiser.XorNode.toObject(includeInstance, f),
    variableNode: (f = msg.getVariableNode()) && proto.instruction_serialiser.LogicalVariableNode.toObject(includeInstance, f),
    ifElseNode: (f = msg.getIfElseNode()) && proto.instruction_serialiser.LogicalIfElseNode.toObject(includeInstance, f),
    greaterThanNode: (f = msg.getGreaterThanNode()) && proto.instruction_serialiser.GreaterThanNode.toObject(includeInstance, f),
    greaterThanOrEqualNode: (f = msg.getGreaterThanOrEqualNode()) && proto.instruction_serialiser.GreaterThanOrEqualNode.toObject(includeInstance, f),
    smallerThanNode: (f = msg.getSmallerThanNode()) && proto.instruction_serialiser.SmallerThanNode.toObject(includeInstance, f),
    smallerThanOrEqualNode: (f = msg.getSmallerThanOrEqualNode()) && proto.instruction_serialiser.SmallerThanOrEqualNode.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.LogicalResultNodeWrapper;
  return proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.LogicalResultNodeWrapper} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.EqualNode;
      reader.readMessage(value,proto.instruction_serialiser.EqualNode.deserializeBinaryFromReader);
      msg.setEqualNode(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.AndNode;
      reader.readMessage(value,proto.instruction_serialiser.AndNode.deserializeBinaryFromReader);
      msg.setAndNode(value);
      break;
    case 3:
      var value = new proto.instruction_serialiser.BoolNode;
      reader.readMessage(value,proto.instruction_serialiser.BoolNode.deserializeBinaryFromReader);
      msg.setBoolNode(value);
      break;
    case 4:
      var value = new proto.instruction_serialiser.NegateNode;
      reader.readMessage(value,proto.instruction_serialiser.NegateNode.deserializeBinaryFromReader);
      msg.setNegateNode(value);
      break;
    case 5:
      var value = new proto.instruction_serialiser.OrNode;
      reader.readMessage(value,proto.instruction_serialiser.OrNode.deserializeBinaryFromReader);
      msg.setOrNode(value);
      break;
    case 6:
      var value = new proto.instruction_serialiser.XorNode;
      reader.readMessage(value,proto.instruction_serialiser.XorNode.deserializeBinaryFromReader);
      msg.setXorNode(value);
      break;
    case 7:
      var value = new proto.instruction_serialiser.LogicalVariableNode;
      reader.readMessage(value,proto.instruction_serialiser.LogicalVariableNode.deserializeBinaryFromReader);
      msg.setVariableNode(value);
      break;
    case 8:
      var value = new proto.instruction_serialiser.LogicalIfElseNode;
      reader.readMessage(value,proto.instruction_serialiser.LogicalIfElseNode.deserializeBinaryFromReader);
      msg.setIfElseNode(value);
      break;
    case 9:
      var value = new proto.instruction_serialiser.GreaterThanNode;
      reader.readMessage(value,proto.instruction_serialiser.GreaterThanNode.deserializeBinaryFromReader);
      msg.setGreaterThanNode(value);
      break;
    case 10:
      var value = new proto.instruction_serialiser.GreaterThanOrEqualNode;
      reader.readMessage(value,proto.instruction_serialiser.GreaterThanOrEqualNode.deserializeBinaryFromReader);
      msg.setGreaterThanOrEqualNode(value);
      break;
    case 11:
      var value = new proto.instruction_serialiser.SmallerThanNode;
      reader.readMessage(value,proto.instruction_serialiser.SmallerThanNode.deserializeBinaryFromReader);
      msg.setSmallerThanNode(value);
      break;
    case 12:
      var value = new proto.instruction_serialiser.SmallerThanOrEqualNode;
      reader.readMessage(value,proto.instruction_serialiser.SmallerThanOrEqualNode.deserializeBinaryFromReader);
      msg.setSmallerThanOrEqualNode(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.LogicalResultNodeWrapper} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEqualNode();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.EqualNode.serializeBinaryToWriter
    );
  }
  f = message.getAndNode();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.AndNode.serializeBinaryToWriter
    );
  }
  f = message.getBoolNode();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.instruction_serialiser.BoolNode.serializeBinaryToWriter
    );
  }
  f = message.getNegateNode();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.instruction_serialiser.NegateNode.serializeBinaryToWriter
    );
  }
  f = message.getOrNode();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.instruction_serialiser.OrNode.serializeBinaryToWriter
    );
  }
  f = message.getXorNode();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.instruction_serialiser.XorNode.serializeBinaryToWriter
    );
  }
  f = message.getVariableNode();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.instruction_serialiser.LogicalVariableNode.serializeBinaryToWriter
    );
  }
  f = message.getIfElseNode();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.instruction_serialiser.LogicalIfElseNode.serializeBinaryToWriter
    );
  }
  f = message.getGreaterThanNode();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.instruction_serialiser.GreaterThanNode.serializeBinaryToWriter
    );
  }
  f = message.getGreaterThanOrEqualNode();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      proto.instruction_serialiser.GreaterThanOrEqualNode.serializeBinaryToWriter
    );
  }
  f = message.getSmallerThanNode();
  if (f != null) {
    writer.writeMessage(
      11,
      f,
      proto.instruction_serialiser.SmallerThanNode.serializeBinaryToWriter
    );
  }
  f = message.getSmallerThanOrEqualNode();
  if (f != null) {
    writer.writeMessage(
      12,
      f,
      proto.instruction_serialiser.SmallerThanOrEqualNode.serializeBinaryToWriter
    );
  }
};


/**
 * optional EqualNode equal_node = 1;
 * @return {?proto.instruction_serialiser.EqualNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getEqualNode = function() {
  return /** @type{?proto.instruction_serialiser.EqualNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.EqualNode, 1));
};


/** @param {?proto.instruction_serialiser.EqualNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setEqualNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearEqualNode = function() {
  this.setEqualNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasEqualNode = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional AndNode and_node = 2;
 * @return {?proto.instruction_serialiser.AndNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getAndNode = function() {
  return /** @type{?proto.instruction_serialiser.AndNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.AndNode, 2));
};


/** @param {?proto.instruction_serialiser.AndNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setAndNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearAndNode = function() {
  this.setAndNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasAndNode = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional BoolNode bool_node = 3;
 * @return {?proto.instruction_serialiser.BoolNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getBoolNode = function() {
  return /** @type{?proto.instruction_serialiser.BoolNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.BoolNode, 3));
};


/** @param {?proto.instruction_serialiser.BoolNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setBoolNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearBoolNode = function() {
  this.setBoolNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasBoolNode = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional NegateNode negate_node = 4;
 * @return {?proto.instruction_serialiser.NegateNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getNegateNode = function() {
  return /** @type{?proto.instruction_serialiser.NegateNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.NegateNode, 4));
};


/** @param {?proto.instruction_serialiser.NegateNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setNegateNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearNegateNode = function() {
  this.setNegateNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasNegateNode = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional OrNode or_node = 5;
 * @return {?proto.instruction_serialiser.OrNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getOrNode = function() {
  return /** @type{?proto.instruction_serialiser.OrNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.OrNode, 5));
};


/** @param {?proto.instruction_serialiser.OrNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setOrNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearOrNode = function() {
  this.setOrNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasOrNode = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional XorNode xor_node = 6;
 * @return {?proto.instruction_serialiser.XorNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getXorNode = function() {
  return /** @type{?proto.instruction_serialiser.XorNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.XorNode, 6));
};


/** @param {?proto.instruction_serialiser.XorNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setXorNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 6, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearXorNode = function() {
  this.setXorNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasXorNode = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional LogicalVariableNode variable_node = 7;
 * @return {?proto.instruction_serialiser.LogicalVariableNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getVariableNode = function() {
  return /** @type{?proto.instruction_serialiser.LogicalVariableNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalVariableNode, 7));
};


/** @param {?proto.instruction_serialiser.LogicalVariableNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setVariableNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 7, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearVariableNode = function() {
  this.setVariableNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasVariableNode = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional LogicalIfElseNode if_else_node = 8;
 * @return {?proto.instruction_serialiser.LogicalIfElseNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getIfElseNode = function() {
  return /** @type{?proto.instruction_serialiser.LogicalIfElseNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalIfElseNode, 8));
};


/** @param {?proto.instruction_serialiser.LogicalIfElseNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setIfElseNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 8, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearIfElseNode = function() {
  this.setIfElseNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasIfElseNode = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional GreaterThanNode greater_than_node = 9;
 * @return {?proto.instruction_serialiser.GreaterThanNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getGreaterThanNode = function() {
  return /** @type{?proto.instruction_serialiser.GreaterThanNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.GreaterThanNode, 9));
};


/** @param {?proto.instruction_serialiser.GreaterThanNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setGreaterThanNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 9, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearGreaterThanNode = function() {
  this.setGreaterThanNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasGreaterThanNode = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional GreaterThanOrEqualNode greater_than_or_equal_node = 10;
 * @return {?proto.instruction_serialiser.GreaterThanOrEqualNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getGreaterThanOrEqualNode = function() {
  return /** @type{?proto.instruction_serialiser.GreaterThanOrEqualNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.GreaterThanOrEqualNode, 10));
};


/** @param {?proto.instruction_serialiser.GreaterThanOrEqualNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setGreaterThanOrEqualNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 10, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearGreaterThanOrEqualNode = function() {
  this.setGreaterThanOrEqualNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasGreaterThanOrEqualNode = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional SmallerThanNode smaller_than_node = 11;
 * @return {?proto.instruction_serialiser.SmallerThanNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getSmallerThanNode = function() {
  return /** @type{?proto.instruction_serialiser.SmallerThanNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.SmallerThanNode, 11));
};


/** @param {?proto.instruction_serialiser.SmallerThanNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setSmallerThanNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 11, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearSmallerThanNode = function() {
  this.setSmallerThanNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasSmallerThanNode = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional SmallerThanOrEqualNode smaller_than_or_equal_node = 12;
 * @return {?proto.instruction_serialiser.SmallerThanOrEqualNode}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.getSmallerThanOrEqualNode = function() {
  return /** @type{?proto.instruction_serialiser.SmallerThanOrEqualNode} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.SmallerThanOrEqualNode, 12));
};


/** @param {?proto.instruction_serialiser.SmallerThanOrEqualNode|undefined} value */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.setSmallerThanOrEqualNode = function(value) {
  jspb.Message.setOneofWrapperField(this, 12, proto.instruction_serialiser.LogicalResultNodeWrapper.oneofGroups_[0], value);
};


proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.clearSmallerThanOrEqualNode = function() {
  this.setSmallerThanOrEqualNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalResultNodeWrapper.prototype.hasSmallerThanOrEqualNode = function() {
  return jspb.Message.getField(this, 12) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.AddNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.AddNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.AddNode.displayName = 'proto.instruction_serialiser.AddNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.AddNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.AddNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.AddNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.AddNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.AddNode}
 */
proto.instruction_serialiser.AddNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.AddNode;
  return proto.instruction_serialiser.AddNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.AddNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.AddNode}
 */
proto.instruction_serialiser.AddNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.AddNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.AddNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.AddNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.AddNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.AddNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.AddNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.AddNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.AddNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.AddNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.AddNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.AddNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.AddNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.ArithmeticIfElseNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.ArithmeticIfElseNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.ArithmeticIfElseNode.displayName = 'proto.instruction_serialiser.ArithmeticIfElseNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.ArithmeticIfElseNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.ArithmeticIfElseNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.ArithmeticIfElseNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    condition: (f = msg.getCondition()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f),
    pb_if: (f = msg.getIf()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    pb_else: (f = msg.getElse()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.ArithmeticIfElseNode}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.ArithmeticIfElseNode;
  return proto.instruction_serialiser.ArithmeticIfElseNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.ArithmeticIfElseNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.ArithmeticIfElseNode}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setCondition(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setIf(value);
      break;
    case 3:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setElse(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.ArithmeticIfElseNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.ArithmeticIfElseNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.ArithmeticIfElseNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCondition();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getIf();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getElse();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional LogicalResultNodeWrapper condition = 1;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.getCondition = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.setCondition = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.ArithmeticIfElseNode.prototype.clearCondition = function() {
  this.setCondition(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.hasCondition = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper if = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.getIf = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.setIf = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.ArithmeticIfElseNode.prototype.clearIf = function() {
  this.setIf(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.hasIf = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ArithmeticResultNodeWrapper else = 3;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.getElse = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 3));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.setElse = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.instruction_serialiser.ArithmeticIfElseNode.prototype.clearElse = function() {
  this.setElse(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ArithmeticIfElseNode.prototype.hasElse = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.ArithmeticVariableNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.ArithmeticVariableNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.ArithmeticVariableNode.displayName = 'proto.instruction_serialiser.ArithmeticVariableNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.ArithmeticVariableNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.ArithmeticVariableNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.ArithmeticVariableNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.ArithmeticVariableNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    variableName: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.ArithmeticVariableNode}
 */
proto.instruction_serialiser.ArithmeticVariableNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.ArithmeticVariableNode;
  return proto.instruction_serialiser.ArithmeticVariableNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.ArithmeticVariableNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.ArithmeticVariableNode}
 */
proto.instruction_serialiser.ArithmeticVariableNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVariableName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.ArithmeticVariableNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.ArithmeticVariableNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.ArithmeticVariableNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.ArithmeticVariableNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVariableName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string variable_name = 1;
 * @return {string}
 */
proto.instruction_serialiser.ArithmeticVariableNode.prototype.getVariableName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.instruction_serialiser.ArithmeticVariableNode.prototype.setVariableName = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.DivideNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.DivideNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.DivideNode.displayName = 'proto.instruction_serialiser.DivideNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.DivideNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.DivideNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.DivideNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.DivideNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.DivideNode}
 */
proto.instruction_serialiser.DivideNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.DivideNode;
  return proto.instruction_serialiser.DivideNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.DivideNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.DivideNode}
 */
proto.instruction_serialiser.DivideNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.DivideNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.DivideNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.DivideNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.DivideNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.DivideNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.DivideNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.DivideNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.DivideNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.DivideNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.DivideNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.DivideNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.DivideNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.LogarithmNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.LogarithmNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.LogarithmNode.displayName = 'proto.instruction_serialiser.LogarithmNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.LogarithmNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.LogarithmNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.LogarithmNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.LogarithmNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.LogarithmNode}
 */
proto.instruction_serialiser.LogarithmNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.LogarithmNode;
  return proto.instruction_serialiser.LogarithmNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.LogarithmNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.LogarithmNode}
 */
proto.instruction_serialiser.LogarithmNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.LogarithmNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.LogarithmNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.LogarithmNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.LogarithmNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.LogarithmNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.LogarithmNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.LogarithmNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogarithmNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.LogarithmNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.LogarithmNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.LogarithmNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogarithmNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.ModuloNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.ModuloNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.ModuloNode.displayName = 'proto.instruction_serialiser.ModuloNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.ModuloNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.ModuloNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.ModuloNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.ModuloNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.ModuloNode}
 */
proto.instruction_serialiser.ModuloNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.ModuloNode;
  return proto.instruction_serialiser.ModuloNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.ModuloNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.ModuloNode}
 */
proto.instruction_serialiser.ModuloNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.ModuloNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.ModuloNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.ModuloNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.ModuloNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.ModuloNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.ModuloNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.ModuloNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ModuloNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.ModuloNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.ModuloNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.ModuloNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.ModuloNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.MultiplyNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.MultiplyNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.MultiplyNode.displayName = 'proto.instruction_serialiser.MultiplyNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.MultiplyNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.MultiplyNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.MultiplyNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.MultiplyNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.MultiplyNode}
 */
proto.instruction_serialiser.MultiplyNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.MultiplyNode;
  return proto.instruction_serialiser.MultiplyNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.MultiplyNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.MultiplyNode}
 */
proto.instruction_serialiser.MultiplyNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.MultiplyNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.MultiplyNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.MultiplyNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.MultiplyNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.MultiplyNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.MultiplyNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.MultiplyNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.MultiplyNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.MultiplyNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.MultiplyNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.MultiplyNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.MultiplyNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.NumberNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.NumberNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.NumberNode.displayName = 'proto.instruction_serialiser.NumberNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.NumberNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.NumberNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.NumberNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.NumberNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: +jspb.Message.getFieldWithDefault(msg, 1, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.NumberNode}
 */
proto.instruction_serialiser.NumberNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.NumberNode;
  return proto.instruction_serialiser.NumberNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.NumberNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.NumberNode}
 */
proto.instruction_serialiser.NumberNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.NumberNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.NumberNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.NumberNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.NumberNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0.0) {
    writer.writeDouble(
      1,
      f
    );
  }
};


/**
 * optional double value = 1;
 * @return {number}
 */
proto.instruction_serialiser.NumberNode.prototype.getValue = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.instruction_serialiser.NumberNode.prototype.setValue = function(value) {
  jspb.Message.setProto3FloatField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.PowerNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.PowerNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.PowerNode.displayName = 'proto.instruction_serialiser.PowerNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.PowerNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.PowerNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.PowerNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.PowerNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.PowerNode}
 */
proto.instruction_serialiser.PowerNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.PowerNode;
  return proto.instruction_serialiser.PowerNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.PowerNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.PowerNode}
 */
proto.instruction_serialiser.PowerNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.PowerNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.PowerNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.PowerNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.PowerNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.PowerNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.PowerNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.PowerNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.PowerNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.PowerNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.PowerNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.PowerNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.PowerNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.SubtractNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.SubtractNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.SubtractNode.displayName = 'proto.instruction_serialiser.SubtractNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.SubtractNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.SubtractNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.SubtractNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.SubtractNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.SubtractNode}
 */
proto.instruction_serialiser.SubtractNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.SubtractNode;
  return proto.instruction_serialiser.SubtractNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.SubtractNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.SubtractNode}
 */
proto.instruction_serialiser.SubtractNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.SubtractNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.SubtractNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.SubtractNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.SubtractNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.SubtractNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.SubtractNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.SubtractNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.SubtractNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.SubtractNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.SubtractNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.SubtractNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.SubtractNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.AndNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.AndNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.AndNode.displayName = 'proto.instruction_serialiser.AndNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.AndNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.AndNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.AndNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.AndNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.AndNode}
 */
proto.instruction_serialiser.AndNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.AndNode;
  return proto.instruction_serialiser.AndNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.AndNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.AndNode}
 */
proto.instruction_serialiser.AndNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.AndNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.AndNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.AndNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.AndNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional LogicalResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.AndNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.AndNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.AndNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.AndNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional LogicalResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.AndNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.AndNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.AndNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.AndNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.BoolNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.BoolNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.BoolNode.displayName = 'proto.instruction_serialiser.BoolNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.BoolNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.BoolNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.BoolNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.BoolNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.BoolNode}
 */
proto.instruction_serialiser.BoolNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.BoolNode;
  return proto.instruction_serialiser.BoolNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.BoolNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.BoolNode}
 */
proto.instruction_serialiser.BoolNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.BoolNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.BoolNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.BoolNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.BoolNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool value = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.instruction_serialiser.BoolNode.prototype.getValue = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.instruction_serialiser.BoolNode.prototype.setValue = function(value) {
  jspb.Message.setProto3BooleanField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.EqualNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.EqualNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.EqualNode.displayName = 'proto.instruction_serialiser.EqualNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.EqualNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.EqualNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.EqualNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.EqualNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.EqualNode}
 */
proto.instruction_serialiser.EqualNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.EqualNode;
  return proto.instruction_serialiser.EqualNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.EqualNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.EqualNode}
 */
proto.instruction_serialiser.EqualNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.EqualNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.EqualNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.EqualNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.EqualNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.EqualNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.EqualNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.EqualNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.EqualNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.EqualNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.EqualNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.EqualNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.EqualNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.GreaterThanNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.GreaterThanNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.GreaterThanNode.displayName = 'proto.instruction_serialiser.GreaterThanNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.GreaterThanNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.GreaterThanNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.GreaterThanNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.GreaterThanNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.GreaterThanNode}
 */
proto.instruction_serialiser.GreaterThanNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.GreaterThanNode;
  return proto.instruction_serialiser.GreaterThanNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.GreaterThanNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.GreaterThanNode}
 */
proto.instruction_serialiser.GreaterThanNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.GreaterThanNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.GreaterThanNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.GreaterThanNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.GreaterThanNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.GreaterThanNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.GreaterThanNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.GreaterThanNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.GreaterThanNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.GreaterThanNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.GreaterThanNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.GreaterThanNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.GreaterThanNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.GreaterThanOrEqualNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.GreaterThanOrEqualNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.GreaterThanOrEqualNode.displayName = 'proto.instruction_serialiser.GreaterThanOrEqualNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.GreaterThanOrEqualNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.GreaterThanOrEqualNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.GreaterThanOrEqualNode}
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.GreaterThanOrEqualNode;
  return proto.instruction_serialiser.GreaterThanOrEqualNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.GreaterThanOrEqualNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.GreaterThanOrEqualNode}
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.GreaterThanOrEqualNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.GreaterThanOrEqualNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.GreaterThanOrEqualNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.LogicalIfElseNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.LogicalIfElseNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.LogicalIfElseNode.displayName = 'proto.instruction_serialiser.LogicalIfElseNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.LogicalIfElseNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.LogicalIfElseNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.LogicalIfElseNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.LogicalIfElseNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    condition: (f = msg.getCondition()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f),
    pb_if: (f = msg.getIf()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f),
    pb_else: (f = msg.getElse()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.LogicalIfElseNode}
 */
proto.instruction_serialiser.LogicalIfElseNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.LogicalIfElseNode;
  return proto.instruction_serialiser.LogicalIfElseNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.LogicalIfElseNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.LogicalIfElseNode}
 */
proto.instruction_serialiser.LogicalIfElseNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setCondition(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setIf(value);
      break;
    case 3:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setElse(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.LogicalIfElseNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.LogicalIfElseNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.LogicalIfElseNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.LogicalIfElseNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCondition();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getIf();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getElse();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional LogicalResultNodeWrapper condition = 1;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.LogicalIfElseNode.prototype.getCondition = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.LogicalIfElseNode.prototype.setCondition = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.LogicalIfElseNode.prototype.clearCondition = function() {
  this.setCondition(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalIfElseNode.prototype.hasCondition = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional LogicalResultNodeWrapper if = 2;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.LogicalIfElseNode.prototype.getIf = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.LogicalIfElseNode.prototype.setIf = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.LogicalIfElseNode.prototype.clearIf = function() {
  this.setIf(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalIfElseNode.prototype.hasIf = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional LogicalResultNodeWrapper else = 3;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.LogicalIfElseNode.prototype.getElse = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 3));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.LogicalIfElseNode.prototype.setElse = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.instruction_serialiser.LogicalIfElseNode.prototype.clearElse = function() {
  this.setElse(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.LogicalIfElseNode.prototype.hasElse = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.LogicalVariableNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.LogicalVariableNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.LogicalVariableNode.displayName = 'proto.instruction_serialiser.LogicalVariableNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.LogicalVariableNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.LogicalVariableNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.LogicalVariableNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.LogicalVariableNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    variableName: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.LogicalVariableNode}
 */
proto.instruction_serialiser.LogicalVariableNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.LogicalVariableNode;
  return proto.instruction_serialiser.LogicalVariableNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.LogicalVariableNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.LogicalVariableNode}
 */
proto.instruction_serialiser.LogicalVariableNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVariableName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.LogicalVariableNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.LogicalVariableNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.LogicalVariableNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.LogicalVariableNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVariableName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string variable_name = 1;
 * @return {string}
 */
proto.instruction_serialiser.LogicalVariableNode.prototype.getVariableName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.instruction_serialiser.LogicalVariableNode.prototype.setVariableName = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.NegateNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.NegateNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.NegateNode.displayName = 'proto.instruction_serialiser.NegateNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.NegateNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.NegateNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.NegateNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.NegateNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    child: (f = msg.getChild()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.NegateNode}
 */
proto.instruction_serialiser.NegateNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.NegateNode;
  return proto.instruction_serialiser.NegateNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.NegateNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.NegateNode}
 */
proto.instruction_serialiser.NegateNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.NegateNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.NegateNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.NegateNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.NegateNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional LogicalResultNodeWrapper child = 1;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.NegateNode.prototype.getChild = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.NegateNode.prototype.setChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.NegateNode.prototype.clearChild = function() {
  this.setChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.NegateNode.prototype.hasChild = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.OrNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.OrNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.OrNode.displayName = 'proto.instruction_serialiser.OrNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.OrNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.OrNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.OrNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.OrNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.OrNode}
 */
proto.instruction_serialiser.OrNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.OrNode;
  return proto.instruction_serialiser.OrNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.OrNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.OrNode}
 */
proto.instruction_serialiser.OrNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.OrNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.OrNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.OrNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.OrNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional LogicalResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.OrNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.OrNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.OrNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.OrNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional LogicalResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.OrNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.OrNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.OrNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.OrNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.SmallerThanNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.SmallerThanNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.SmallerThanNode.displayName = 'proto.instruction_serialiser.SmallerThanNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.SmallerThanNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.SmallerThanNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.SmallerThanNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.SmallerThanNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.SmallerThanNode}
 */
proto.instruction_serialiser.SmallerThanNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.SmallerThanNode;
  return proto.instruction_serialiser.SmallerThanNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.SmallerThanNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.SmallerThanNode}
 */
proto.instruction_serialiser.SmallerThanNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.SmallerThanNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.SmallerThanNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.SmallerThanNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.SmallerThanNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.SmallerThanNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.SmallerThanNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.SmallerThanNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.SmallerThanNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.SmallerThanNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.SmallerThanNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.SmallerThanNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.SmallerThanNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.SmallerThanOrEqualNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.SmallerThanOrEqualNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.SmallerThanOrEqualNode.displayName = 'proto.instruction_serialiser.SmallerThanOrEqualNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.SmallerThanOrEqualNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.SmallerThanOrEqualNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.ArithmeticResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.SmallerThanOrEqualNode}
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.SmallerThanOrEqualNode;
  return proto.instruction_serialiser.SmallerThanOrEqualNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.SmallerThanOrEqualNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.SmallerThanOrEqualNode}
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.ArithmeticResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.ArithmeticResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.SmallerThanOrEqualNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.SmallerThanOrEqualNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.ArithmeticResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional ArithmeticResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ArithmeticResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.ArithmeticResultNodeWrapper}
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.ArithmeticResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.ArithmeticResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.ArithmeticResultNodeWrapper|undefined} value */
proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.SmallerThanOrEqualNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.instruction_serialiser.XorNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.instruction_serialiser.XorNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.instruction_serialiser.XorNode.displayName = 'proto.instruction_serialiser.XorNode';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.instruction_serialiser.XorNode.prototype.toObject = function(opt_includeInstance) {
  return proto.instruction_serialiser.XorNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.instruction_serialiser.XorNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.XorNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    leftChild: (f = msg.getLeftChild()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f),
    rightChild: (f = msg.getRightChild()) && proto.instruction_serialiser.LogicalResultNodeWrapper.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.instruction_serialiser.XorNode}
 */
proto.instruction_serialiser.XorNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.instruction_serialiser.XorNode;
  return proto.instruction_serialiser.XorNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.instruction_serialiser.XorNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.instruction_serialiser.XorNode}
 */
proto.instruction_serialiser.XorNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setLeftChild(value);
      break;
    case 2:
      var value = new proto.instruction_serialiser.LogicalResultNodeWrapper;
      reader.readMessage(value,proto.instruction_serialiser.LogicalResultNodeWrapper.deserializeBinaryFromReader);
      msg.setRightChild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.instruction_serialiser.XorNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.instruction_serialiser.XorNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.instruction_serialiser.XorNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.instruction_serialiser.XorNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeftChild();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
  f = message.getRightChild();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.instruction_serialiser.LogicalResultNodeWrapper.serializeBinaryToWriter
    );
  }
};


/**
 * optional LogicalResultNodeWrapper left_child = 1;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.XorNode.prototype.getLeftChild = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 1));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.XorNode.prototype.setLeftChild = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.instruction_serialiser.XorNode.prototype.clearLeftChild = function() {
  this.setLeftChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.XorNode.prototype.hasLeftChild = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional LogicalResultNodeWrapper right_child = 2;
 * @return {?proto.instruction_serialiser.LogicalResultNodeWrapper}
 */
proto.instruction_serialiser.XorNode.prototype.getRightChild = function() {
  return /** @type{?proto.instruction_serialiser.LogicalResultNodeWrapper} */ (
    jspb.Message.getWrapperField(this, proto.instruction_serialiser.LogicalResultNodeWrapper, 2));
};


/** @param {?proto.instruction_serialiser.LogicalResultNodeWrapper|undefined} value */
proto.instruction_serialiser.XorNode.prototype.setRightChild = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.instruction_serialiser.XorNode.prototype.clearRightChild = function() {
  this.setRightChild(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.instruction_serialiser.XorNode.prototype.hasRightChild = function() {
  return jspb.Message.getField(this, 2) != null;
};


goog.object.extend(exports, proto.instruction_serialiser);
